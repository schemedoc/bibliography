(group "Compiler Technology/Implementation Techniques and Optimization")

(group "Basic Techniques")

(id steele1978rabbit)
(type techreport)
(title "Rabbit: A compiler for Scheme")
(author "Steele Jr, Guy L")
(year 1978)
(month 5)
(number "AITR-474")
(institution "Massachusetts Institute of Technology")
(pdf-sha1 "77e89aa6508d00e505dfb7ca98c141357d8caccb")
(pdf "https://archive.org/download/bitsavers_mitaiaimAI_11751904/AITR-474.pdf")
(abstract "We have developed a compiler for the lexically-scoped dialect of LISP known as SCHEME. The compiler knows relatively little about specific data manipulation primitives such as arithmetic operators, but concentrates on general issues of environment and control. Rather than having specialized knowledge about a large variety of control and environment constructs, the compiler handles only a small basis set which reflects the semantics of lambda-calculus. All of the traditional imperative constructs, such as sequencing, assignment, looping, GO TO, as well as many standard LISP constructs such as AND, OR and COND, are expressed as macros in terms of the applicative basis set. A small number of optimization techniques, coupled with the treatment of function calls as GO TO statements, serves to produce code as good as that produced by more traditional compilers.")

(id adams1986orbit)
(type article)
(title "Orbit: An optimizing compiler for Scheme")
(author "Adams, Norman")
(author "Kranz, David")
(author "Kelsey, Richard")
(author "Rees, Jonathan")
(author "Hudak, Paul")
(author "Philbin, James")
(journal "ACM SIGPLAN Notices")
(volume "21")
(number "7")
(pages "219--233")
(year 1986)
(month 6)
(publisher "ACM New York, NY, USA")
(pdf-sha1 "7eaea33f91c32ca3bd13888eefcf7879d68c33ba")
(pdf "https://people.csail.mit.edu/riastradh/t/adams86orbit.pdf")
(pdf "https://www.academia.edu/download/49363232/adams86orbit.pdf")
(abstract "In this paper we describe an optimizing compiler for Scheme (3, 13] called Orbit that incorporates our experience with an earlier Scheme compiler called TC (10, 11], together with some ideas from Steele's Rabbit compiler. The three main design goals have been correctness, gencrating very efficient compiled code, and portability." "In spirit, Orbit is similar to the Rabbit compiler in that it depends on a translation of source code into \"continuation-passing style\" (CPS), a convenient intermediate form that makes control-flow explicit. After CPS conversion, procedures take an extra argument called a continuation (another procedure) that represents the next logical execution point after execution of the procedure body. Thus procedures do not \"return,\" but rather \"continue into\" the code represented by the continuation. This permits, for example, a general but simple way to optimize tail-recursions into loops." "Steele's seminal work on Rabbit demonstrated the general benefits of this approach to compiler design. However, his work was primarily research oriented, and Rabbit was essentially a prototype compiler (consider, for example, that it generated MACLISP code). TC, on the other hand, was one of the first practical compilers for a Scheme dialect, and much was learned through its design and construction.\" Orbit now represents a culmination of that learning process, in which CPS conversion has been implemented thoroughly, extended in critical ways, and set in a framework of other important compiler innovations to yield a practical compiler that generates production-quality code competitive with the best compilers for Lisp as well as non-Lisp languages.")

;; Also: YALEU/DCS/TR632
(id kranz1988orbit)
(type phdthesis)
(title "Orbit: An Optimizing Compiler for Scheme")
(author "Kranz, David")
(year 1988)
(month 6)
(school "Department of Computer Science, Yale University")
(pdf-sha1 "514a5c2deb540cebeb879d396ab027aca9b2731c")
(pdf "https://cpsc.yale.edu/sites/default/files/files/tr632.pdf")
(abstract "It has often been assumed that the performance of languages with rst-class procedures is necessarily inferior to that of more traditional languages. Both experience and benchmarks appear to support this assumption. This work shows that the performance penalty is only a result of applying conventional compiler technologies to the compilation of higher order languages. These technologies do not adapt well to the situation in which closures of unlimited extent can be created dynamically." "The ORBIT compiler is based on a continuation-passing model instead of the traditional procedure call/return. The problem of reducing heap storage is solved using new algorithms for closure analysis, allowing many objects to be allocated on a stack or, better still, in machine registers. Closure packing and hoisting allow more than one procedure to share an environment without introducing indirection. Move instructions and memory references are reduced by passing arguments in registers and using a dynamic register allocation strategy. Register allocation and code generation are accomplished at the same time, with environment pointers being treated as variables. Environment pointers are kept in a lazy display, being brought into registers and cached when needed. The interaction of this strategy with the closure analysis also allows many optimizations based on type information to be performed." "Benchmarks are presented to show that, using these new techniques, the performance of programs written in higher order languages almost equals that of programs written in Pascal in both space and time. Thus the greater expressive power of higher order languages and debugging ease of traditional LISP systems need not be sacri ced to attain good performance.")

(id feeley1986deux)
(type mastersthesis)
(title "Deux approches à l'implantation du langage Scheme")
(author "Feeley, Marc")
(year 1986)
(school "Université de Montréal")
(pdf-sha1 "22e0485c3cbda78fef823ca52d30821b296173ed")
(pdf "https://www-labs.iro.umontreal.ca/~feeley/papers/FeeleyMSc.pdf")
(ps "http://www.iro.umontreal.ca/~feeley/papers/msc.ps.gz")
(abstract "Le langage Scheme est un dialecte de Lisp simple et homogène qui gagne de la popularité. Ce mémoire porte sur l'implantation efficace de deux aspects importants d'un système Scheme, c'est-à-dire les fermetures et la génération de code. Pour chacun de ces aspects, nous proposons une nouvelle approche d'implantation et la comparons à d'autres méthodes connues." "Notre approche d'implantation de fermetures est fondée sur le principe de β-conversion du λ-calcul. Nous raffinons une méthode simple basée sur cette dernière ce qui nous amène à concevoir les fermetures comme étant un bout de code. Les avantages de cette approche sont discutés et, à l'aide d'une batterie de tests, nous en analysons la performance. Les résultats obtenus indiquent que dans plusieurs situations notre approche est supérieure à l'approche classique." "Nous montrons qu'il est possible d'utiliser les fermetures pour représenter le code généré par un compilateur. Cette approche permet d'écrire un compilateur Scheme totalement en Scheme et de remplacer avantageusement les interpréteurs. De plus, cette approche peut être étendue à d'autres langages tel que les langages orienté-objet. L'intégration de cette approche dans un compilateur optimisant nous a permis d'en mesurer l'efficacité par rapport à d'autres méthodes d'évaluation." "L'implantation d'un système Scheme combinant nos deux approches a été réalisée. À l'aide de tests comparant celui-ci à d'autres systèmes couramment disponibles sur le marché, nous montrons la viabilité d'un système basé sur nos deux approches.")

(id dybvig1987three)
(type phdthesis)
(title "Three implementation models for Scheme")
(author "Dybvig, R Kent")
(year 1987)
(school "University of North Carolina at Chapel Hill")
(pdf-sha1 "bc896e5336120b0f4ad00feb500cd7ce70134836")
(pdf "https://mazdaywik.github.io/direct-link/dybvig-disser.pdf")
(pdf "https://legacy.cs.indiana.edu/~dyb/papers/3imp.pdf")
(abstract "This dissertation presents three implementation models for the Scheme Programming Language. The first is a heap-based model used in some form in most Scheme implementations to date; the second is a new stack-based model that is considerably more efficient than the heap-based model at executing most programs; and the third is a new string-based model intended for use in a multiple-processor implementation of Scheme. The heap-based model allocates several important data structures in a heap, including actual parameter lists, binding environments, and call frames. The stack-based model allocates these same structures on a stack whenever possible. This results in less heap allocation, fewer memory references, shorter instruction sequences, less garbage collection, and more efficient use of memory. The string-based model allocates versions of these structures right in the program text, which is represented as a string of symbols. In the string-based model, Scheme programs are translated into an FFP language designed specifically to support Scheme. Programs in this language are directly executed by the FFP machine, a multiple-processor string-reduction computer. The stack-based model is of immediate practical benefit; it is the model used by the author's Chez Scheme system, a high-performance implementation of Scheme. The string-based model will be useful for providing Scheme as a high-level alternative to FFP on the FFP machine once the machine is realized.")

(id clinger1984scheme)
(type inproceedings)
(title "The Scheme 311 compiler: an exercise in denotational semantics")
(author "Clinger, William")
(booktitle "Proceedings of the 1984 ACM Symposium on LISP and functional programming")
(pages "356--364")
(year 1984)
(pdf-sha1 "e3daa2373e23694144fae2f8ec99b2bd503abfcb")
(abstract "Many authors have offered much good advice on structuring compilers and proving them correct [3, 12, 13, 27, 28]. The correctness proof described here demonstrates that their advice can be applied to a useful compiler for a real programming language. This paper describes and proves the correctness of a simple compiler algorithm for Scheme, a statically scoped dialect of Lisp. The algorithm has been used as the basis for an interactive compiler generating interpreted byte code in an implementation comparable to those available for Pascal, Smalltalk, and Basic [1, 7, 9]." "Most of the correctness proof consists of trivial calculations. This is possible because the meanings of target code instructions are expressed in the same language used to express source meanings, and that language can be wielded as a calculus. The proof is complicated by what amounts to a static type distinction needed to compile primitive operators in line. Previous compiler correctness proofs using static type information (eg [179 have assumed that separate presentations of static and dynamic semantics are available a priori, but the proof in this paper works from a single standard semantics." "The proof is similar in spirit to that of, though the algorithm was designed and a compiler built before any thought was given to a formal correctness proof. The algorithm is superior to that in in that it directly produces linear and properly tail-recursive object code of reasonable quality.")

(id bartley1986implementation)
(type inproceedings)
(title "The implementation of PC Scheme")
(author "Bartley, David H")
(author "Jensen, John C")
(booktitle "Proceedings of the 1986 ACM conference on LISP and functional programming")
(pages "86--93")
(year 1986)
(pdf-sha1 "d68ebbed3f12e295e18f39dad48cf53afbd6ef40")
(abstract "PC Scheme is a compiler-based implementation of Scheme for PC-class machines. The compiler generates code for an idealized virtual machine which is emulated with threaded code techniques. The design has traded off the requirements of space sad speed effectively, resulting in one of the fastest PC-class LISP systems known to the authors.")

(id serrano2000vers)
(type phdthesis)
(title "Vers une programmation fonctionnelle praticable")
(author "Serrano, Manuel")
(year 2000)
(month 9)
(school "Université de Nice Sophia-Antipolis")
(pdf-sha1 "acf4864d29801d22720bdda8b800e9f1c5187bc2")
(ps-sha1 "6aed4169480c4fbe385d5e4fc0483ea1c4cc0653")
(ps "https://www-sop.inria.fr/members/Manuel.Serrano/publi/serrano-hdr00.ps.gz")
(abstract "A programmation est une activité terriblement difficile. Elle est tellement complexe et laborieuse qu'on finit méme par accepter la piétre qualité de la plupart des réalisations informatiques. L'industrie du logiciel est la seule (avec peut-étre les compagnies on aériennes qui sont incapables de respecter les horaires des avions) qui soit parvenue a établir le commerce de produits aussi instables et hasardeux que sont la plupart des logiciels actuels. Personne ne sait trés bien ce que les dits logiciels font ; les éditeurs informatiques se dé- gageant, pour leur part, de toute responsabilité en cas de dysfonctionnement. La notion méme de garantie est inopérante car personne n'aurait |'« audace» de spécifier ce qu'un logiciel est supposé faire. Les déficiences de l'informatique ont des impacts de plus en plus nombreux dans notre vie quotidienne a tel point que méme les journaux d'informations générales les relatent. Ainsi, dans le quotidien Le Monde, daté du Dimanche 26/Lundi 27 Décembre 1999, on a pu lire")

(id serrano1995bigloo)
(type inproceedings)
(title "Bigloo: a portable and optimizing compiler for strict functional languages")
(author "Serrano, Manuel")
(author "Weis, Pierre")
(booktitle "International Static Analysis Symposium")
(pages "366--381")
(year 1995)
(month 9)
(organization "Springer")
(pdf-sha1 "e9f6988ba5a9cc8f6cd9a9437968580215981eeb")
(pdf "http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.50.8424&rep=rep1&type=pdf")
(ps "https://www-sop.inria.fr/members/Manuel.Serrano/publi/sw-sas95.ps.gz")
(abstract "We present Bigloo, a highly portable and optimizing compiler. Bigloo is the rst compiler for strict functional languages that can efficiently compile several languages: Bigloo is the rst compiler for full Scheme and full ML, and for these two languages, Bigloo is one of the most efficient compiler now available (Bigloo is available by anonymous ftp on ftp.inria.fr [192.93.2.54])." "This high level of performance is achieved by numerous high-level optimizations. Some of those are classical optimizations adapted to higherorder functional languages (e.g. inlining), other optimization schemes are speci c to Bigloo (e.g. a new re ned closure analysis, an original optimization of imperative variables, and intensive use of higher-order control ow analysis). All these optimizations share the same design guideline: the reduction of heap allocation.")

(id rees1995security)
(type phdthesis)
(title "A security kernel based on the lambda-calculus")
(author "Rees, Jonathan A")
(year 1995)
(school "Massachusetts Institute of Technology")
(pdf-sha1 "93c25e5faa0bb20c56202dc135c20c621e313187")
(pdf "https://dspace.mit.edu/bitstream/handle/1721.1/36956/32890570-MIT.pdf;sequence=2")
(ps "https://groups.csail.mit.edu/mac/ftpdir/users/jar/archive/whole.ps")
(abstract "Cooperation between independent agents depends upon establishing a degree of security. Each of the cooperating agents needs assurance that the cooperation will not endanger resources of value to that agent. In a computer system, a computational mechanism can assure safe cooperation among the system's users by mediating resource access according to desired security policy. Such a mechanism, which is called a security kernel, lies at the heart of many operating systems and programming environments." "The dissertation describes Scheme 48, a programming environment whose design is guided by established principles of operating system security. Scheme 48's security kernel is small, consisting of the call-by-value A-calculus with a few simple extensions to support abstract data types, object mutation, and access to hardware resources. Each agent (user or subsystem) has a separate evaluation environment that holds objects representing privileges granted to that agent. Because environments ultimately determine availability of object references, protection and sharing can be controlled largely by the way in which environments are constructed." "I will describe experience with Scheme 48 that shows how it serves as a robust and flexible experimental platform. Two successful applications of Scheme 48 are the programming environment for the Cornell mobile robots, where Scheme 48 runs with no (other) operating system support; and a secure multi-user environment that runs on workstations.")

(id kelsey1994tractable)
(type article)
(title "A tractable Scheme implementation")
(author "Kelsey, Richard A")
(author "Rees, Jonathan A")
(journal "Lisp and Symbolic Computation")
(volume "7")
(number "4")
(pages "315--335")
(year 1994)
(publisher "Springer")
(scheme-id scheme48)
(pdf-sha1 "3acd9fb69ef052223814ba75dcb6b1308e576be2")
(pdf "http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.459.8113&rep=rep1&type=pdf")
(abstract "Scheme 48 is an implementation of the Scheme programming language constructed with tractability and reliability as its primary design goals. It has the structural properties of large, compiler-based Lisp implementations: it is written entirely in Scheme, is bootstrapped via its compiler, and provides numerous language extensions. It controls the complexity that ordinarily attends such large Lisp implementations through clear articulation of internal modularity and by the exclusion of features, optimizations, and generalizations that are of only marginal value.")

(id clinger1994lambda)
(type article)
(title "Lambda, the ultimate label or a simple optimizing compiler for Scheme")
(author "Clinger, William D")
(author "Hansen, Lars Thomas")
(journal "ACM SIGPLAN Lisp Pointers")
(volume "7")
(number "3")
(pages "128--139")
(year 1994)
(publisher "ACM New York, NY, USA")
(pdf-sha1 "1ddcec59325b6932e7d5d6a9facf2451bf0d4d76")
(abstract "Optimizing compilers for higher-order languages need not be terribly complex. The problems created bv non-local, non-global variables can be eliminated by allocating all such variables in the heap. Lambda lifting makes this practical by eliminating all non-local variables except for those that would have to be allocated in the heap anyway. The eliminated non-local variables become local variables that can be allocated in registers. Since calls to known procedures are just gotos that pass arguments, lifted lambda expressions are just assembly language labels that have been augmented by a list of symbolic names for the registers that are live at that label.")

(id clinger1988implementation)
(type inproceedings)
(title "Implementation strategies for continuations")
(author "Clinger, Will")
(author "Hartheimer, Anne")
(author "Ost, Eric")
(booktitle "Proceedings of the 1988 ACM conference on LISP and functional programming")
(pages "124--131")
(year 1988)
(month 7)
(pdf-sha1 "d995e99d9179e671f6543ef2f22f4743718a1955")
(abstract "Scheme and Smalltalk continuations may have unlimited extent. This means that a purely stack-based implementation of continuations, as suffices for most languages, is inadequate. Several implementation strategies have been described in the literature. Determining which is best requires knowledge of the kinds of programs that will commonly be run." "Danvy, for example, has conjectured that continuation captures occur in clusters. That is, the same continuation, once captured, is likely to be captured again. As evidence, Danvy cited the use of continuations in a research setting. We report that Danvy's conjecture is somewhat true in the commercial setting of MacScheme+Toolsmith, which provides tools for developing Macintosh user interfaces in Scheme. These include an interrupt-driven event system and multitasking, both implemented by liberal use of continuations." "We describe several implementation strategies for continuations and compare four of them using benchmarks. We conclude that the most popular strategy may have a slight edge when continuations are not used at all, but that other strategies perform better when continuations are used and Danvy's conjecture holds.")

(id clinger2006rapid)
(type inproceedings)
(title "Rapid Case Dispatch in Scheme")
(author "Clinger, William D")
(booktitle "2006 Workshop on Scheme and Functional Programming")
(year 2006)
(month 9)
(pdf-sha1 "69e43684e7d12cbf368fcea9f28330c6c426699c")
(pdf "https://www.ccs.neu.edu/home/will/Research/SW2006/casedispatch.pdf")
(abstract "The case expressions of Scheme can and should be implemented efficiently. A three-level dispatch performs well, even when dispatching on symbols, and scales to large case expressions.")

(id bruggeman1996representing)
(type inproceedings)
(title "Representing control in the presence of one-shot continuations")
(author "Bruggeman, Carl")
(author "Waddell, Oscar")
(author "Dybvig, R Kent")
(booktitle "Proceedings of the ACM SIGPLAN 1996 conference on Programming language design and implementation")
(pages "99--107")
(year 1996)
(month 6)
(pdf-sha1 "573a255da8c25555f231863717d20f3a91825649")
(ps-sha1 "b254497626a05ea27e186b22a8c59031258227de")
(ps "https://legacy.cs.indiana.edu/~dyb/papers/Call-1cc-PLDI96.ps.gz")
(abstract "Traditional first-class continuation mechanisms allow a captured continuation to be invoked multiple times. Many continuations, however, are invoked only once. This paper introduces one-shot continuations, shows how they interact with traditional multi-shot continuations, and describes a stack-based implementation of control that handles both one-shot and multi-shot continuations. The implementation eliminates the copying overhead for one-shot continuations that is inherent in multi-shot continuations.")

(id hilsdale1995compiler)
(type inproceedings)
(title "Compiler construction using scheme")
(author "Hilsdale, Erik")
(author "Ashley, J Michael")
(author "Dybvig, R Kent")
(author "Friedman, Daniel P")
(booktitle "International Symposium on Functional Programming Languages in Education")
(pages "251--267")
(year 1995)
(organization "Springer")
(pdf-sha1 "857a8441c017c3f1ce678506e003397e8e3d09a1")
(pdf-sha1 "068ceb1e9066fe36f336b815c0cb4cceac48d3f4")
(pdf "https://legacy.cs.indiana.edu/~dyb/pubs/fple95.pdf")
(pdf "https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.54.8685&rep=rep1&type=pdf")
(abstract "This paper describes a course in compiler design that focuses on the Scheme implementation of a Scheme compiler that generates native assembly code for a real architecture. The course is suitable for advanced undergraduate and beginning graduate students. It is intended both to provide a general knowledge about compiler design and implementation and to serve as a springboard to more advanced courses. Although this paper concentrates on the implementation of a compiler, an outline for an advanced topics course that builds upon the compiler is also presented.")

(id ashley1994efficient)
(type inproceedings)
(title "An efficient implementation of multiple return values in Scheme")
(author "Ashley, J Michael")
(author "Dybvig, R Kent")
(booktitle "Proceedings of the 1994 ACM Conference on LISP and Functional Programming")
(pages "140--149")
(year 1994)
(month 6)
(pdf-sha1 "bf54700a2b96de14a2a86411f8d20969f423f25c")
(abstract "This paper describes an implementation of the new Scheme multiple values interface. The implementation handles multiple values efficiently, with no run-time overhead for normal calls and returns. Error checks are performed where necessary to insure that the expected number of values is returned in all situations. The implementation fits cleanly with our direct-style compiler and stack-based representation of control, but is equally well suited to continuation-passing style compilers and to heap-based run-time architectures.")

(id hieb1990representing)
(type article)
(title "Representing control in the presence of first-class continuations")
(author "Hieb, Robert")
(author "Dybvig, R Kent")
(author "Bruggeman, Carl")
(journal "ACM SIGPLAN Notices")
(volume "25")
(number "6")
(pages "66--77")
(year 1990)
(month 6)
(publisher "ACM New York, NY, USA")
(pdf-sha1 "8e24b81541ab6310e6882d57dfd3f26fdbe3e204")
(ps-sha1 "b1ed86fef928546f79ee1bf3c297db986757783b")
(ps "https://legacy.cs.indiana.edu/~dyb/papers/stack.ps")
(abstract "Languages such as Scheme and Smalltalk that provide continuations as first-class data objects present a challenge to efficient implementation. Allocating activation records in a heap has proven unsatisfactory because of increased frame linkage costs, increased garbage collection overhead, and decreased locality of reference. However, simply allocating activation records on a stack and copying them when a continuation is created results in unbounded copying overhead. This paper describes a new approach based on stack allocation that does not require the stack to be copied when a continuation is created and that allows us to place a small upper bound on the amount copied when a continuation is reinstated. This new approach is faster than the naive stack allocation approach, and it does not suffer from the problems associated with unbounded copying. For continuationintensive programs, our approach is at worst a constant factor slower than the heap allocation approach, and for typical programs, it is significantly faster. An important additional benefit is that recovery from stack overflow is handled gracefully and efficiently.")

(id flanagan1993essence)
(type inproceedings)
(title "The essence of compiling with continuations")
(author "Flanagan, Cormac")
(author "Sabry, Amr")
(author "Duba, Bruce F")
(author "Felleisen, Matthias")
(booktitle "Proceedings of the ACM SIGPLAN 1993 conference on Programming language design and implementation")
(pages "237--247")
(year 1993)
(pdf-sha1 "227d2f191ca8b87aae66497a9015448ce64d7312")
(ps-sha1 "222729baf3f0e29ba31186f67bf8d198a7c1e742")
(ps "https://www.ccs.neu.edu/scheme/pubs/pldi93-fsdf.ps.gz")
(abstract "In order to simplify the compilation process, many compilers for higher-order languages use the continuation-passing style (CPS) transformation in a first phase to generate an intermediate representation of the source program. The salient aspect of this intermediate form is that all procedures take an argument that represents the rest of the computation (the \"continuation\"). Since the naive CPS transformation considerably increases the size of programs, CPS compilers perform reductions to produce a more compact intermediate representation. Although often implemented as a part of the CPS transformation, this step is conceptually a second phase. Finally, code generators for typical CPS compilers treat continuations specially in order to optimize the interpretation of continuation parameters." "A thorough analysis of the abstract machine for CPS terms shows that the actions of the code generator invert the naive CPS translation step. Put differently, the combined effect of the three phases is equivalent to a source-to-source transformation that simulates the compaction phase. Thus, fully developed CPS compilers do not need to employ the CPS transformation but can achieve the same results with a simple source-level transformation.")

(id sabry1995formal)
(type phdthesis)
(title "The formal relationship between direct and continuation-passing style optimizing compilers: a synthesis of two paradigms")
(author "Sabry, Amr Afaf")
(year 1995)
(school "Rice University")
(pdf-sha1 "161933785d6ad0d040f8e18beef829624cd72cf9")
(ps-sha1 "48b300524261740d870d6d292b23557b734a1737")
(pdf "https://scholarship.rice.edu/bitstream/handle/1911/16878/9610702.PDF?sequence=1")
(ps "https://www.ccs.neu.edu/scheme/pubs/thesis-sabry.ps.gz")
(abstract "Compilers for higher-order programming languages like Scheme, ML, and Lisp can be broadly characterized as either \"direct compilers\" or \"continuation-passing style (CPS) compilers\", depending on their main intermediate representation. Our central result is a precise correspondence between the two compilation strategies." "Starting from the theoretical foundations of direct and CPS compilers, we develop relationships between the main components of each compilation strategy: generation of the intermediate representation, simplification of the intermediate representation, code generation, and data flow analysis. For each component, our results pinpoint the superior compilation strategy, the reason for which it dominates the other strategy, and ways to improve the inferior strategy. Furthermore, our work suggests a synthesis of the direct and CPS compilation strategies that combines the best aspects of each." "The contributions of this thesis include a comprehensive analysis of the properties of the CPS iniermediate representation, a new optimal CPS transformation and its inverse, a new intermediate representation for direct compilers, an equivalence between the canonical equational theories for reasoning about continuations and general computational effects, a sound and complete equational axiomatization of the semantics of call-by-value control operators, a methodology for deriving equational logics for imperative languages, and formal relationships between code generators and data flow analyzers for direct and CPS compilers. These contributions unify concepts in two distinct compilation strategies, and can be used to compare specific compilers.")

(id queinnec1993continuation)
(type article)
(title "Continuation conscious compilation")
(author "Queinnec, Christian")
(journal "ACM SIGPLAN Lisp Pointers")
(volume "6")
(number "1")
(pages "2--14")
(year 1993)
(month 1)
(publisher "ACM New York, NY, USA")
(pdf-sha1 "40de0e38059b23aec4f68345f386ebd1992dbf72")
(pdf-sha1 "be66e6574ed18e5f8d014dc422c6e43aa8a236ac")
(pdf "https://christian.queinnec.org/PDF/ccc.pdf")
(pdf "https://pages.lip6.fr/Christian.Queinnec/PDF/ccc.pdf")
(abstract "This paper proposes some (unimplemented) ideas for the compilation of Scheme-like languages where functions may be specialized with respect to some of the continuations with which they are invoked. This allows for some optimizations, for instance, when a frame to be pushed and the frame on top of the continuation can be combined into a single and simplified frame. Among possible improvements are: intermediate data structure elimination and removal of useless calculations. Functions can therefore be compiled with respect to their near future and reorganize it when appropriate." "The compilation technique is based on a program transformation named Abstract Continuation Passing Style that makes continuation (i.e. stack) frames explicit. Shape of continuations is approximated to determine which frames would gain by being combined together then partial evaluation is used to determine the behavior of combined frames. Our main results cover local deforestation-like effect as well as iterative compilation of associatively wrapped recursions converting, for example, a recursive unary factorial into an iterative binary one.")

(id queinnec1992continuation)
(type techreport)
(title "Continuation sensitive compilation")
(author "Queinnec, Christian")
(year 1992)
(month 11)
(institution "Research Report LIX RR 92/14, Laboratoire d'Informatique de l'Ecole~...")
(pdf-sha1 "8d9998d8bac52074fe47d29310340980ce9baf32")
(pdf "https://pages.lip6.fr/Christian.Queinnec/PDF/csc.pdf")
(pdf "https://christian.queinnec.org/PDF/csc.pdf")
(abstract "This paper presents a compilation technique for Scheme-like languages where functions may look at their continuation before pushing frames onto it. This allows for some optimizations when the frame to be pushed and the frame on top of the continuation can be combined into a single and simplified frame. Among possible simplifications are: intermediate data structure elimination and removal of redundant calculations. Functions can therefore be compiled with respect to their near future and reorganize it when appropriate." "The compilation technique is based on an improved CPS-like transformation that makes continuation (i.e. stack) frames explicit. Shape of continuations is approximated to determine which frames would gain by being combined together then partial evaluation is used to determine the behavior of combined frames. Our main results cover local deforestation-like effect as well as iterative compilation of associatively wrapped recursions.")

(id thiemann1999higher)
(type inproceedings)
(title "Higher-order code splicing")
(author "Thiemann, Peter")
(booktitle "European Symposium on Programming")
(pages "243--257")
(year 1999)
(month 3)
(organization "Springer")
(pdf-sha1 "84c9be0fb04f75c1c240c5a5f21a3b49b486d18c")
(ps-sha1 "28937d21f4b2249cac4563462e5d00d24ec526a5")
(pdf "https://link.springer.com/content/pdf/10.1007/3-540-49099-X_16.pdf")
(ps "http://www.informatik.uni-freiburg.de/~thiemann/papers/esop99.ps.gz")
(abstract "Run-time code generation (RTCG) and just-in-time compilation (JIT) are features of modern programming systems to strike the balance between generality and efficiency. Since RTCG and JIT techniques are not portable and notoriously hard to implement, we propose code splicing as an alternative for dynamically-typed higher-order programming languages. Code splicing combines precompiled pieces of code using higher-order functions. While this approach cannot achieve the performance of compiled code, it can support some intriguing features:" "– very fast \"compilation\" times;" "– satisfactory run times, compared with interpretation;" "– simple interfacing with compiled code;" "– portability." "Starting from implementation models for functional languages we develop and evaluate several approaches to code splicing. This leads to some new insights into compilation techniques for functional programming languages, among them a compositional compilation schema to SKI-combinators. The progression of different techniques sheds some light on their relationship, specifically between combinator-based implementations and closure-based implementations." "All techniques have been implemented and evaluated in Scheme.")

(id steele1977debunking)
(type inproceedings)
(title "Debunking the \"expensive procedure call\" myth or, procedure call implementations considered harmful or, LAMBDA: The Ultimate GOTO")
(author "Steele Jr, Guy Lewis")
(booktitle "Proceedings of the 1977 annual ACM conference")
(pages "153--162")
(year 1977)
(pdf-sha1 "bdc7b4eda3995fe20320ddde753b3630612b05c5")
(abstract "Folklore states that GOTO statements are \"cheap\", while procedure calls are \"expensive\". This myth is largely a result of poorly designed language implementations. The historical growth of this myth is considered. Both theoretical ideas and an existing implementation are discussed which debunk this myth. It is shown that the unrestricted use of procedure calls permits great stylistic freedom. In particular, any flowchart can be written as a \"structured\" program without introducing extra variables. The difficulty with the GOTO statement and the procedure call is characterized as a conflict between abstract programming concepts and concrete language constructs.")

;; S. B. Thesis.
(id rozas1984liar)
(type article)
(title "Liar, an Algol-like compiler for Scheme")
(author "Rozas, Guillermo J")
(school "Massachusetts Institute of Technology")
(year 1984)
(month 1)

;; MIT LCS Memo TM-267
(id schooler1984proposal)
(type techreport)
(title "Proposal for a Small Scheme Implementation")
(author "Schooler, Richard")
(author "Stamos, James W")
(year 1984)
(month 10)
(institution "Massachusetts Institute of Technology LCS")
(pdf-sha1 "661be241bd585d54c0ad1a81c47ea4257dac096e")
(pdf-sha1 "b5912b7fc31dc43b80adfa1a71c181d1fe101939")
(pdf "https://apps.dtic.mil/dtic/tr/fulltext/u2/a148707.pdf")
(pdf "http://publications.csail.mit.edu/lcs/pubs/pdf/MIT-LCS-TM-267.pdf")
(abstract "Scheme is a lexically scoped dialect of LISP developed at MIT. In this report we determine the feasibility of implementing a Scheme-based programming/application environment on a contemporary personal computer such as the Apple Macintosh. The absence of virtual memory, coupled with a limitation on the maximum amount of physical memory, means that space is at a premium. We suggest the use of bytecodes and sketch a possible instruction set." "Because of space constraints, tail-recursion optimization and an efficient mechanism for the reclamation of inaccessible contexts are also examined. Using the built-in operating system and user interface of the Macintosh realizes speed, functionality, and friendliness but raises a number of interesting issues. For example, the Pascal! and assembler routines make many assumptions about data representation, type checking, and parameter passing. Since an implementation of Scheme is likely to have radically different conventions, the two environments must be interfaced smoothly and efficiently." "In addition to the bytecoded instruction set, we specify the virtual machine informally, discuss the implementation of basic and advanced features, estimate the performance of such an implementation, and finally evaluate the proposed design.")

(id wand1986interpreter)
(type incollection)
(title "From interpreter to compiler: a representational derivation")
(author "Wand, Mitchell")
(booktitle "Programs as Data Objects")
(pages "306--324")
(year 1986)
(publisher "Springer")

(id wand1978compiling)
(type article)
(title "Compiling lambda-expressions using continuations and factorizations")
(author "Wand, Mitchell")
(author "Friedman, Daniel P")
(journal "Computer Languages")
(volume "3")
(number "4")
(pages "241--263")
(year 1978)
(publisher "Pergamon Press, Inc.")

(id steele1980compiler)
(type misc)
(title "Compiler optimization based on viewing LAMBDA as RENAME + GOTO")
(author "Steele Jr, Guy Lewis")
(year 1980)
(book "Artificial Intelligence: An MIT Perspective")
(publisher "MIT Press")

(end-group)

(end-group)
